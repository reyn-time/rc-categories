// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteInterval = `-- name: DeleteInterval :exec
DELETE FROM reorder.video_intervals
WHERE id = $1
`

func (q *Queries) DeleteInterval(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteInterval, id)
	return err
}

const deleteIntervalCategories = `-- name: DeleteIntervalCategories :exec
DELETE FROM reorder.video_interval_categories
WHERE video_interval_id = $1
`

func (q *Queries) DeleteIntervalCategories(ctx context.Context, videoIntervalID int32) error {
	_, err := q.db.Exec(ctx, deleteIntervalCategories, videoIntervalID)
	return err
}

const getUser = `-- name: GetUser :one
SELECT id, email, name, photo_url
FROM reorder.users
WHERE email = $1
`

func (q *Queries) GetUser(ctx context.Context, email string) (ReorderUser, error) {
	row := q.db.QueryRow(ctx, getUser, email)
	var i ReorderUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PhotoUrl,
	)
	return i, err
}

const listCategories = `-- name: ListCategories :many
SELECT id, name, description, parent_id, rank
FROM reorder.categories
`

func (q *Queries) ListCategories(ctx context.Context) ([]ReorderCategory, error) {
	rows, err := q.db.Query(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReorderCategory
	for rows.Next() {
		var i ReorderCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ParentID,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCurrentAppointments = `-- name: ListCurrentAppointments :many
SELECT a.id, a.start_time, a.patient_id,
    p.initials,
    p.gender
FROM reorder.patient_appointments a
    INNER JOIN reorder.patients p ON a.patient_id = p.id
WHERE start_time AT TIME ZONE 'UTC' >= NOW()
ORDER BY start_time ASC
`

type ListCurrentAppointmentsRow struct {
	ID        int32
	StartTime pgtype.Timestamp
	PatientID int32
	Initials  string
	Gender    ReorderGender
}

func (q *Queries) ListCurrentAppointments(ctx context.Context) ([]ListCurrentAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, listCurrentAppointments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCurrentAppointmentsRow
	for rows.Next() {
		var i ListCurrentAppointmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.StartTime,
			&i.PatientID,
			&i.Initials,
			&i.Gender,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIntervals = `-- name: ListIntervals :many
SELECT id, video_id, start_time, end_time, description, video_interval_id, array_agg
FROM reorder.video_intervals v
    JOIN (
        select video_interval_id,
            array_agg(category_id)
        from reorder.video_interval_categories
        group by video_interval_id
    ) c ON v.id = c.video_interval_id
WHERE video_id = $1
ORDER BY v.start_time
`

type ListIntervalsRow struct {
	ID              int32
	VideoID         int32
	StartTime       float32
	EndTime         float32
	Description     pgtype.Text
	VideoIntervalID int32
	ArrayAgg        interface{}
}

func (q *Queries) ListIntervals(ctx context.Context, videoID int32) ([]ListIntervalsRow, error) {
	rows, err := q.db.Query(ctx, listIntervals, videoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIntervalsRow
	for rows.Next() {
		var i ListIntervalsRow
		if err := rows.Scan(
			&i.ID,
			&i.VideoID,
			&i.StartTime,
			&i.EndTime,
			&i.Description,
			&i.VideoIntervalID,
			&i.ArrayAgg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatients = `-- name: ListPatients :many
WITH la as (
    SELECT patient_id,
        MAX(start_time) as last_appointment,
        COUNT(*) as appointments_count
    FROM reorder.patient_appointments
    GROUP BY patient_id
)
SELECT patient_id, last_appointment, appointments_count, id, initials, gender, status
FROM la
    INNER JOIN reorder.patients p on la.patient_id = p.id
ORDER BY patient_id ASC
`

type ListPatientsRow struct {
	PatientID         int32
	LastAppointment   interface{}
	AppointmentsCount int64
	ID                int32
	Initials          string
	Gender            ReorderGender
	Status            ReorderPatientStatus
}

func (q *Queries) ListPatients(ctx context.Context) ([]ListPatientsRow, error) {
	rows, err := q.db.Query(ctx, listPatients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPatientsRow
	for rows.Next() {
		var i ListPatientsRow
		if err := rows.Scan(
			&i.PatientID,
			&i.LastAppointment,
			&i.AppointmentsCount,
			&i.ID,
			&i.Initials,
			&i.Gender,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, name, photo_url
FROM reorder.users
`

func (q *Queries) ListUsers(ctx context.Context) ([]ReorderUser, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReorderUser
	for rows.Next() {
		var i ReorderUser
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.PhotoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideos = `-- name: ListVideos :many
SELECT v.id, v.name, v.youtube_id, v.created_at, v.status, v.editor,
    u.id as user_id,
    u.email,
    u.name as user_name,
    u.photo_url
FROM reorder.videos v
    LEFT JOIN reorder.users u ON v.editor = u.id
ORDER BY created_at DESC
`

type ListVideosRow struct {
	ID        int32
	Name      string
	YoutubeID string
	CreatedAt pgtype.Timestamp
	Status    ReorderVideoStatus
	Editor    pgtype.Int4
	UserID    pgtype.Int4
	Email     pgtype.Text
	UserName  pgtype.Text
	PhotoUrl  pgtype.Text
}

func (q *Queries) ListVideos(ctx context.Context) ([]ListVideosRow, error) {
	rows, err := q.db.Query(ctx, listVideos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVideosRow
	for rows.Next() {
		var i ListVideosRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.YoutubeID,
			&i.CreatedAt,
			&i.Status,
			&i.Editor,
			&i.UserID,
			&i.Email,
			&i.UserName,
			&i.PhotoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postInterval = `-- name: PostInterval :one
INSERT INTO reorder.video_intervals (video_id, start_time, end_time, description)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type PostIntervalParams struct {
	VideoID     int32
	StartTime   float32
	EndTime     float32
	Description pgtype.Text
}

func (q *Queries) PostInterval(ctx context.Context, arg PostIntervalParams) (int32, error) {
	row := q.db.QueryRow(ctx, postInterval,
		arg.VideoID,
		arg.StartTime,
		arg.EndTime,
		arg.Description,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const postIntervalCategory = `-- name: PostIntervalCategory :exec
INSERT INTO reorder.video_interval_categories (video_interval_id, category_id)
VALUES ($1, $2)
`

type PostIntervalCategoryParams struct {
	VideoIntervalID int32
	CategoryID      int32
}

func (q *Queries) PostIntervalCategory(ctx context.Context, arg PostIntervalCategoryParams) error {
	_, err := q.db.Exec(ctx, postIntervalCategory, arg.VideoIntervalID, arg.CategoryID)
	return err
}

const updateInterval = `-- name: UpdateInterval :exec
UPDATE reorder.video_intervals
SET start_time = $2,
    end_time = $3,
    description = $4
WHERE id = $1
`

type UpdateIntervalParams struct {
	ID          int32
	StartTime   float32
	EndTime     float32
	Description pgtype.Text
}

func (q *Queries) UpdateInterval(ctx context.Context, arg UpdateIntervalParams) error {
	_, err := q.db.Exec(ctx, updateInterval,
		arg.ID,
		arg.StartTime,
		arg.EndTime,
		arg.Description,
	)
	return err
}

const updateVideoEditor = `-- name: UpdateVideoEditor :exec
UPDATE reorder.videos
SET editor = $2
WHERE id = $1
`

type UpdateVideoEditorParams struct {
	ID     int32
	Editor pgtype.Int4
}

func (q *Queries) UpdateVideoEditor(ctx context.Context, arg UpdateVideoEditorParams) error {
	_, err := q.db.Exec(ctx, updateVideoEditor, arg.ID, arg.Editor)
	return err
}

const updateVideoStatus = `-- name: UpdateVideoStatus :exec
UPDATE reorder.videos
SET status = $2
WHERE id = ANY($1::integer [])
`

type UpdateVideoStatusParams struct {
	Column1 []int32
	Status  ReorderVideoStatus
}

func (q *Queries) UpdateVideoStatus(ctx context.Context, arg UpdateVideoStatusParams) error {
	_, err := q.db.Exec(ctx, updateVideoStatus, arg.Column1, arg.Status)
	return err
}

const upsertUser = `-- name: UpsertUser :exec
INSERT INTO reorder.users (email, name, photo_url)
VALUES ($1, $2, $3) ON CONFLICT (email) DO
UPDATE
SET name = $2,
    photo_url = $3
`

type UpsertUserParams struct {
	Email    string
	Name     string
	PhotoUrl string
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) error {
	_, err := q.db.Exec(ctx, upsertUser, arg.Email, arg.Name, arg.PhotoUrl)
	return err
}
