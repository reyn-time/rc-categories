// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPatient = `-- name: CreatePatient :exec
INSERT INTO reorder.patients (initials, gender)
VALUES ($1, $2)
`

type CreatePatientParams struct {
	Initials string
	Gender   ReorderGender
}

func (q *Queries) CreatePatient(ctx context.Context, arg CreatePatientParams) error {
	_, err := q.db.Exec(ctx, createPatient, arg.Initials, arg.Gender)
	return err
}

const createPatientAppointment = `-- name: CreatePatientAppointment :exec
INSERT INTO reorder.patient_appointments (start_time, patient_id)
VALUES ($1, $2)
`

type CreatePatientAppointmentParams struct {
	StartTime pgtype.Timestamp
	PatientID int32
}

func (q *Queries) CreatePatientAppointment(ctx context.Context, arg CreatePatientAppointmentParams) error {
	_, err := q.db.Exec(ctx, createPatientAppointment, arg.StartTime, arg.PatientID)
	return err
}

const deleteInterval = `-- name: DeleteInterval :exec
DELETE FROM reorder.video_intervals
WHERE id = $1
`

func (q *Queries) DeleteInterval(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteInterval, id)
	return err
}

const deleteIntervalCategories = `-- name: DeleteIntervalCategories :exec
DELETE FROM reorder.video_interval_categories
WHERE video_interval_id = $1
`

func (q *Queries) DeleteIntervalCategories(ctx context.Context, videoIntervalID int32) error {
	_, err := q.db.Exec(ctx, deleteIntervalCategories, videoIntervalID)
	return err
}

const deletePatientAppointment = `-- name: DeletePatientAppointment :exec
DELETE FROM reorder.patient_appointments
WHERE id = $1
`

func (q *Queries) DeletePatientAppointment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePatientAppointment, id)
	return err
}

const getUser = `-- name: GetUser :one
SELECT id, email, name, photo_url
FROM reorder.users
WHERE email = $1
`

func (q *Queries) GetUser(ctx context.Context, email string) (ReorderUser, error) {
	row := q.db.QueryRow(ctx, getUser, email)
	var i ReorderUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PhotoUrl,
	)
	return i, err
}

const listCategories = `-- name: ListCategories :many
SELECT id, name, description, parent_id, rank
FROM reorder.categories
`

func (q *Queries) ListCategories(ctx context.Context) ([]ReorderCategory, error) {
	rows, err := q.db.Query(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReorderCategory
	for rows.Next() {
		var i ReorderCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ParentID,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCurrentAppointments = `-- name: ListCurrentAppointments :many
select s.id, s.start_time, s.patient_id, s.meeting_number
from (
        select id, start_time, patient_id,
            rank() over (
                partition by patient_id
                order by start_time asc
            ) meeting_number
        from reorder.patient_appointments
    ) s
where s.start_time AT TIME ZONE 'UTC' > now() - interval '8 week'
ORDER BY start_time ASC
`

type ListCurrentAppointmentsRow struct {
	ID            int32
	StartTime     pgtype.Timestamp
	PatientID     int32
	MeetingNumber int64
}

func (q *Queries) ListCurrentAppointments(ctx context.Context) ([]ListCurrentAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, listCurrentAppointments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCurrentAppointmentsRow
	for rows.Next() {
		var i ListCurrentAppointmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.StartTime,
			&i.PatientID,
			&i.MeetingNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIntervals = `-- name: ListIntervals :many
SELECT id, video_id, start_time, end_time, description, video_interval_id, array_agg
FROM reorder.video_intervals v
    JOIN (
        select video_interval_id,
            array_agg(category_id)
        from reorder.video_interval_categories
        group by video_interval_id
    ) c ON v.id = c.video_interval_id
WHERE video_id = $1
ORDER BY v.start_time
`

type ListIntervalsRow struct {
	ID              int32
	VideoID         int32
	StartTime       float32
	EndTime         float32
	Description     pgtype.Text
	VideoIntervalID int32
	ArrayAgg        interface{}
}

func (q *Queries) ListIntervals(ctx context.Context, videoID int32) ([]ListIntervalsRow, error) {
	rows, err := q.db.Query(ctx, listIntervals, videoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIntervalsRow
	for rows.Next() {
		var i ListIntervalsRow
		if err := rows.Scan(
			&i.ID,
			&i.VideoID,
			&i.StartTime,
			&i.EndTime,
			&i.Description,
			&i.VideoIntervalID,
			&i.ArrayAgg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatients = `-- name: ListPatients :many
SELECT id, initials, gender, status
FROM reorder.patients
ORDER BY id ASC
`

func (q *Queries) ListPatients(ctx context.Context) ([]ReorderPatient, error) {
	rows, err := q.db.Query(ctx, listPatients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReorderPatient
	for rows.Next() {
		var i ReorderPatient
		if err := rows.Scan(
			&i.ID,
			&i.Initials,
			&i.Gender,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, name, photo_url
FROM reorder.users
`

func (q *Queries) ListUsers(ctx context.Context) ([]ReorderUser, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReorderUser
	for rows.Next() {
		var i ReorderUser
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.PhotoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideos = `-- name: ListVideos :many
SELECT v.id, v.name, v.youtube_id, v.created_at, v.status, v.editor,
    u.id as user_id,
    u.email,
    u.name as user_name,
    u.photo_url
FROM reorder.videos v
    LEFT JOIN reorder.users u ON v.editor = u.id
ORDER BY created_at DESC
`

type ListVideosRow struct {
	ID        int32
	Name      string
	YoutubeID string
	CreatedAt pgtype.Timestamp
	Status    ReorderVideoStatus
	Editor    pgtype.Int4
	UserID    pgtype.Int4
	Email     pgtype.Text
	UserName  pgtype.Text
	PhotoUrl  pgtype.Text
}

func (q *Queries) ListVideos(ctx context.Context) ([]ListVideosRow, error) {
	rows, err := q.db.Query(ctx, listVideos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVideosRow
	for rows.Next() {
		var i ListVideosRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.YoutubeID,
			&i.CreatedAt,
			&i.Status,
			&i.Editor,
			&i.UserID,
			&i.Email,
			&i.UserName,
			&i.PhotoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postInterval = `-- name: PostInterval :one
INSERT INTO reorder.video_intervals (video_id, start_time, end_time, description)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type PostIntervalParams struct {
	VideoID     int32
	StartTime   float32
	EndTime     float32
	Description pgtype.Text
}

func (q *Queries) PostInterval(ctx context.Context, arg PostIntervalParams) (int32, error) {
	row := q.db.QueryRow(ctx, postInterval,
		arg.VideoID,
		arg.StartTime,
		arg.EndTime,
		arg.Description,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const postIntervalCategory = `-- name: PostIntervalCategory :exec
INSERT INTO reorder.video_interval_categories (video_interval_id, category_id)
VALUES ($1, $2)
`

type PostIntervalCategoryParams struct {
	VideoIntervalID int32
	CategoryID      int32
}

func (q *Queries) PostIntervalCategory(ctx context.Context, arg PostIntervalCategoryParams) error {
	_, err := q.db.Exec(ctx, postIntervalCategory, arg.VideoIntervalID, arg.CategoryID)
	return err
}

const updateInterval = `-- name: UpdateInterval :exec
UPDATE reorder.video_intervals
SET start_time = $2,
    end_time = $3,
    description = $4
WHERE id = $1
`

type UpdateIntervalParams struct {
	ID          int32
	StartTime   float32
	EndTime     float32
	Description pgtype.Text
}

func (q *Queries) UpdateInterval(ctx context.Context, arg UpdateIntervalParams) error {
	_, err := q.db.Exec(ctx, updateInterval,
		arg.ID,
		arg.StartTime,
		arg.EndTime,
		arg.Description,
	)
	return err
}

const updatePatientAppointment = `-- name: UpdatePatientAppointment :exec
UPDATE reorder.patient_appointments
SET start_time = $2
WHERE id = $1
`

type UpdatePatientAppointmentParams struct {
	ID        int32
	StartTime pgtype.Timestamp
}

func (q *Queries) UpdatePatientAppointment(ctx context.Context, arg UpdatePatientAppointmentParams) error {
	_, err := q.db.Exec(ctx, updatePatientAppointment, arg.ID, arg.StartTime)
	return err
}

const updatePatientStatus = `-- name: UpdatePatientStatus :exec
UPDATE reorder.patients
SET status = $2
WHERE id = $1
`

type UpdatePatientStatusParams struct {
	ID     int32
	Status ReorderPatientStatus
}

func (q *Queries) UpdatePatientStatus(ctx context.Context, arg UpdatePatientStatusParams) error {
	_, err := q.db.Exec(ctx, updatePatientStatus, arg.ID, arg.Status)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE reorder.users
SET name = $1,
    photo_url = $2
WHERE email = $3
RETURNING id, email, name, photo_url
`

type UpdateUserParams struct {
	Name     string
	PhotoUrl string
	Email    string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (ReorderUser, error) {
	row := q.db.QueryRow(ctx, updateUser, arg.Name, arg.PhotoUrl, arg.Email)
	var i ReorderUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PhotoUrl,
	)
	return i, err
}

const updateVideoEditor = `-- name: UpdateVideoEditor :exec
UPDATE reorder.videos
SET editor = $2
WHERE id = $1
`

type UpdateVideoEditorParams struct {
	ID     int32
	Editor pgtype.Int4
}

func (q *Queries) UpdateVideoEditor(ctx context.Context, arg UpdateVideoEditorParams) error {
	_, err := q.db.Exec(ctx, updateVideoEditor, arg.ID, arg.Editor)
	return err
}

const updateVideoStatus = `-- name: UpdateVideoStatus :exec
UPDATE reorder.videos
SET status = $2
WHERE id = ANY($1::integer [])
`

type UpdateVideoStatusParams struct {
	Column1 []int32
	Status  ReorderVideoStatus
}

func (q *Queries) UpdateVideoStatus(ctx context.Context, arg UpdateVideoStatusParams) error {
	_, err := q.db.Exec(ctx, updateVideoStatus, arg.Column1, arg.Status)
	return err
}
